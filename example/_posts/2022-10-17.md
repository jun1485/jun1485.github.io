개발자로서 '효율'이라는 키워드는 참 중요하게 생각이 된다.
오늘은 성능 향상을 위해 어떤 것을 해보았는지 회고해보겠다.

먼저, 나에게 react를 사용하려는 이유를 딱 하나만 꼽아보라면
'컴포넌트 단위 프로그래밍'이라고 하고싶다.
그 이유라고 하면 '생산성과 유지보수를 용이하게 한다'일텐데,
구체적으로 내가 어떻게 이 장점을 활용했는지 풀어보겠다.



위 사진에 보이는 모든 부분은 인자만 다르게 주면 어디서든 재사용 가능하게 설계되었다.
예시 몇 가지만 들어보겠다.

(👇 클릭했을 때 isActive 값을 toggle해서 페이지를 전환 할 수 있도록 설계)


styled component로 구성하여 props를 통해 전달받은 인자로
css-in-js를 이용해 동적 UI를 구성했다.



(👇 정규표현식을 이용한 유효성검사를 토대로 동적인 styling이 가능한 input)


그리고 위 페이지와는 별개이지만 페이지네이션 부분도 custom hook으로
다른 상태의 인자만 전해주면 그 인자를 토대로 재사용되어
전혀 다른 페이지네이션을 구성해 줄 수 있는 Provider도 만들어
코드의 재사용을 최소화시키는 컴포넌트들을 설계했다.



그리고, 리액트를 사용하며 성능에 가장 큰 영향을 주는 것은
Life Cycle이라고 생각한다.

Life Cycle은 크게는 생성될때(Mount), 업데이트 될때(Update),
제거될 때(Unmount)로 나눌 수 있는데, Update될 때가
제일 중요하지 않을까 싶다. 그 이유는 Mount, Unmount는
case와 기준이 명확하기 때문에 추적이 쉬운데,

Update의 경우
state의 상태가 바뀔 때
props의 상태가 바뀔 때
부모 컴포넌트가 리렌더링 될 때
강제 update로 렌더링할 때
위와 같이 경우의 수가 많다. 또 redux를 쓰는 경우, store를 부르는 행위조차
리렌더링을 일으키는데, 이런 사소한 것 하나하나 제대로 이해하지 못하고
사용할 경우, 사용이 매우 자유로운 React의 경우
정말 양날의 검이 될 수 있기 때문에 update가 정말 중요하다고 생각이 된다.

그래서, update가 언제 어떻게 일어나고 있는지 테스트를 해보았다.
아래사진은 메인화면에서 cards들을 불러오는 로직들에 콘솔을 찍어본 건데,
메인화면에 들어올 때마다 아래 리렌더링 작업이 총 3번씩 일어났다.


이유가 뭘까.. 하며 컴포넌트의 렌더링 과정 하나하나를 들여다 보았다.



이유는 총 두 가지가 있었다.
useEffect()의 첫번째 인자는 App이 실행되면 처음 한번은 무조건 실행이 된다. dependency array로 빈배열을 주더라도 말이다.
나의 경우에는 card들을 불러오는 main페이지와 맞물려있는 pagination 컴포넌트에서 페이지 변환을 위해 사용한 useEffect가 문제였다.
해당 부분은 useEffect안에서 실행해주는 대신, 아래 사진과 같이 함수로 만들어주어 페이지가 클릭되면 이 함수가 트리거되도록 변경했다.


card 컴포넌트에서 카드들을 render시켜주는 useEffect의 의존성배열로
dispatch를 넣어줬었다.
사실, 의존성 배열로써 dispatch는 별다른 의미가 없다.
함수의 형태로써 react에서 항상 고정된 형태로 존재하기 때문에
별다른 동작의 변화가 없기 때문.
card 컴포넌트가 렌더링 될 때 자식인 cardItem 컴포넌트의
dispatch도 트리거하기 때문에 일어나는 리렌더링이었다.
해당 의존성 배열을 없애줌으로 렌더링을 한번 더 줄일 수 있었다.

위에서 소개한 것들 하나하나가 성능에도 영향을 미쳐
최종적으로 Load Page Profiling Test에서 함수 총 호출시간을 약 34% 줄였다.
고도화의 중요성을 새삼 깨닫는다.
